---
layout: post
title: Java 中的比较运算符
categories: Java
description: Java 中的比较运算符里有没有什么陷阱呢？
keywords: Java
---

## Java 比较运算符里的一些细节

* `>`、`>=`、`<` 和 `<=` 只支持两边操作数都是数值类型。
* `==` 和 `!=` 两边的操作数可以都是数值类型，也可以都是引用类型，但必须是同一个类的实例。
* 当 `obj1` 和 `obj2` 引用同一个对象时，则 `obj1 == obj2`，否则 `obj1 != obj2`。
* 每种数值类型都有对应的包装类，比如 long 的包装类 Long。包装类的实例可以与数值型的值比较，是直接取出包装类实例所包装的数值来比较的。
* 涉及自动装箱后情况复杂了一些，比如

  ```java
  Integer ina = 18;
  Integer inb = 18;

  Integer inc = 188;
  Integer ind = 188;
  ```

  这时 `ina == inb` 成立，而 `inc == ind` 不成立。

  原因是在 java.lang.Integer 类里，对 -128~127 之间的整数自动装箱成 Integer 实例，并且缓存了起来，所以对此范围内的整数自动装箱时，实际上都指向了缓存里的对象，所以会出现上面的情况。

  与此类似的是 String 类型也会对诸如 `String stra = "Hello";` 这样的直接赋值创建的实例进行缓存。

## 最佳实践

* 引用类型实例之间，除非想要知道是否是引用同一个对象，否则它们之间的比较，总是使用 `equals()` 方法。

## 参考

《疯狂 Java 讲义》——李刚著 第 3.7.5 节 比较运算符。
