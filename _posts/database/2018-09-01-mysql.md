---
layout: post
title: MySQL 数据库相关知识整理
categories: Database
description: MySQL 数据库相关知识整理
keywords: database, mysql, 原理, 数据库
---

MySQL 数据库在互联网业务中的地位无需多言，本文从各个方面整理 MySQL 数据库的知识点。

关于数据库基础理论知识，请查看：[数据库基础整理](/2018/05/01/database)。

## 底层原理

MySQL 底层是使用了哪些技术，使得其具备高性能的特性呢？

### 逻辑组成结构

![image](/images/posts/mysql_structure.png)

- 连接处理层
  - 客户端网络连接处理
  - 授权认证
  - 安全认证等
- 核心层
  - 查询解析
  - 分析优化
  - 缓存
  - 函数、存储过程、触发器、视图
- 存储引擎层
  - 执行事务处理操作
  - 数据存储和读取
  - 不解析 SQL，只是响应上层请求
  - 实现锁机制

### 存储引擎

MySQL 的存储引擎主要包括：

- MyISAM
  - 低版本默认引擎
  - 支持全文检索、压缩、空间函数
  - 不支持事务和行级锁
  - 对全表加锁
- InnoDB
  - 高版本默认引擎
  - 默认的事务性引擎
  - 性能优越、自动崩溃回复特性
  - 采用 MVCC 实现高并发、实现不同隔离级别
  - 基于聚簇索引建立表
  - 采用可预测性预读的技术从磁盘加载数据
  - 存储引擎实现
    - 最小存储单元是页
    - 页大小为 16K（参数 `innodb_page_size`）
    - `.ibd` 大小是 16K 的整数倍
- Archive/Memory/CSV 等

## 索引及其优化

- 索引速度快

  正常情况下在查询数据时，需要遍历磁盘扇区内所有数据；通过在索引中记录待查询字段、记录对应位置，可以快速筛选出结果集；假如需要回表查询非索引字段，只需要根据索引中记录的扇区位置查找对应行数据即可。

  InnoDB 表是基于聚簇索引建立的。InnoDB 的索引结构和 MySQL 的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能，不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

  InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建 hash 索引以加速读操作的自适应哈希索引（adaptive hash index），以及能够加速插入操作的插入缓冲区（insert buffer）等。

- 索引的数据结构和底层实现
  - B-Tree
    - B-Tree 的每个节点可以拥有 2 个以上的子节点，是一颗多路平衡查找树，它广泛应用于数据库索引和文件系统中。
  - B+Tree：[数据结构整理-B+Tree](/2019/01/01/data-structure/#B%2bTree)
    - 每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历
    - 每个节点的指针上限为2d而不是2d+1
    - 内节点不存储data，只存储key；叶子节点不存储指针。
    - 每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。
  - 磁盘结构及其索引设计：[Linux 系统磁盘相关概念](/2018/07/01/disk)
- 聚簇索引 Clustered index
  - 是一种数据存储方式，InnoDB 的在实现聚簇索引时，将**索引**和**数据行**保存在了同一个结构
  - 通常 InnoDB 表的聚簇索引就是主键
    - 若表中定义了主键则主键作为聚簇索引
    - 若表中无主键，且所有 key 的列为非空，则使用表的第一个 unique 索引作为聚簇索引
    - 若表中无主键也没有合适的 unique 索引，则内部生成一个包含 rowId 的隐藏的 `GEN_CLUST_INDEX` 列
  - 主键按顺序插入是最快的插入方式，否则建议 `OPTIMIZE TABLE`
  - 更新聚簇索引列的代价较高，会强制被更新的行移动到新位置
  - 可能会导致全表扫描变慢，比如行稀疏、页分裂导致存储不连续时
- 非聚簇索引
  - 就是指 B+Tree 的叶子节点上的 data 并不是数据本身，而是数据存放的地址。
  - 非聚簇索引比聚簇索引多了一次读取数据的 I/O 操作，所以查找性能上会差。
- 索引类型
  - 主键索引、唯一索引、普通索引、联合索引、全文索引
  - B-Tree
  - Hash
  - R-Tree
  - fulltext
- 索引优点
  - 减少扫描数据量
  - 避免临时排序和临时表
  - 将随机 I/O 变为顺序 I/O
- 联合索引 index merge
- 优化方向
  - 建立索引
  - 按顺序建立索引
  - 尽量覆盖索引避免回表
  - “三星”索引原则
    - WHERE 条件使用索引查询记录则获得一星
    - 如果索引中的数据顺序和查找中的排列顺序一致则获得二星
    - 如果索引中的列包含了查询中需要的全部列则获得“三星”
- 异常优化原因/不走索引
  - 执行计划的成本估算与实际执行成本异常
- 优化策略
  - 反例
    - 参与函数计算
    - 隐式类型转换（会导致索引失效）
  - 正例
    - varchar 前缀索引指定长度
      - 确定区分度方式见下面 sql 片段
      - 可以使得索引更小、更有效
      - 缺点：无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。
    - 唯一特性字段必建 unique 索引
    - 禁止左模糊/全模糊查询
    - order by 字段的索引有序性
      - 正例：`where a =? and b =? order by c;` 索引： `a_b_c` 正常生效
      - 反例：索引中有范围查找，那么索引有序性无法利用，如：`WHERE a >10 ORDER BY b;` 索引
           `a_b` 无法排序
    - 利用覆盖索引避免回表
    - 利用延迟关联或子查询优化大量数据分页场景
    - 区分度高的索引在左边，区分度低的（如性别年龄省份等字段）在后面
- 优化目标指标
  - 最低 `range`，要求是 `ref`，`consts` 最好
  - 若 `type=index` 相当于全表扫描性能最差
- 判断索引的区分度

```sql
-- varchar 列区分度判断
SELECT COUNT(*) AS cnt,LEFT(city,3) AS pref FROM t_city GROUP BY pref ORDER BY cnt DESC LIMIT 10; -- 查找合适的列
SELECT COUNT(DISTINCT LEFT(列名, 索引长度))/COUNT(*) FROM t_city;
ALTER TABLE t_city ADD KEY (city(6));-- 设置索引长度
```

- 延迟关联

```sql
SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id; -- 阿里开发手册示例
SELECT a.* FROM 表 1 a, (select id from 表 1 where id > 100000 LIMIT 20 ) b where a.id=b.id;
-- (sex，rating) 索引
SELECT <cols> FROM profiles INNER JOIN (
 SELECT <primary key cols> FROM profiles
 WHERE x.sex='M' ORDER BY rating LIMIT 100000, 10
AS x USING(<primary key cols>);
```

- 索引失效

  明明建立了索引的语句，但是查询效率还是很慢，通过 explain 分析发现表中有多个索引，MySQL 的优化器选用了错误的索引，导致查询效率偏低，此时可以在 SQL 语句中使用 `force use index(...)` 来指定索引解决。

- EXISTS 索引？

分组查询的SELECT中直接使用非分组列。建议始终使用含义明确的语法。事实上，我们建议将MySQL的SQL_MODE设置为包含 ONLY_FULL_GROUP_BY，这时MySQL会对这类查询直接返回一个错误，提醒你需要重写这个查询。

> `ONLY_FULL_GROUP_BY` Reject queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are neither named in the GROUP BY clause nor are functionally dependent on (uniquely determined by) GROUP BY columns.

### 索引长度

varchar 类型字段的索引长度默认是最大长度 255 个字符，MySQL 默认每个 utf-8 字符占 3 字节。

### 数据存储碎片化

- 行碎片
  - 数据被存储在多个地方
- 行间碎片
  - 逻辑上连续的行却不是顺序存储
- 剩余空间碎片
  - 数据页中有大量空余空间

```sql
OPTIMIZE TABLE <table>; -- MyISAM
ALTER TABLE <table> ENGINE=<engine>; -- InnoDB 换为同一个引擎
```

## MySQL InnoDB Locking

当多个查询需要在同一时刻修改数据，就会产生并发控制的问题。解决这类问题的方法就是并发控制。

### 共享锁和排它锁

InnoDB 实现了两种行级别锁， shared (S) locks 和 exclusive (X) locks。

- 共享锁允许持锁事务读取行记录
- 排它锁允许持锁事务更新、删除行记录
- 当某事务持有 row 的 S 锁时：
  - 其他事务可以立刻获取到 row 的 S 锁（即多个事务同时获取 row 的 S 锁）
  - 其他事务不能立刻获取到 row 的 X 锁
- 当某事务持有 row 的 X 锁时：
  - 则 row 的 S 锁和 X 锁 均不能被其他事务立刻获取到
  - 需等待当前事务释放 row 的锁

共享锁和排他锁也叫读锁（read lock）和写锁（write lock），读锁是共享的，相互不阻塞；写锁是排他的，会阻塞其他的写锁和读锁，以确保在给定的时间里只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

#### 意向锁

当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被**排他锁**占用的时候，该事务可以在需要锁定行的**表**上面添加一个合适的意向锁。

如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。

意向共享锁可以同时并存多个，但是**意向排他锁同时只能有一个存在**。所以，可以说 InnoDB 的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX），我们可以通过以下表格来总结上面这四种所的共存逻辑关系：

- 意向锁定义

  InnoDB 支持多种粒度的锁以实现行锁和表锁共存，例如 `LOCK TABLES ... WRITE` 会在指定表上加 X 锁。InnoDB 使用意向锁使多粒度锁更为实用：

  意向锁是表级锁，用于说明事务随后将要获取的是哪种类型的锁（S 或 X），分为两种：

  - intention shared lock (IS) 表示某事务意图获取表中某些 row 的 S 锁
    - `SELECT ... LOCK IN SHARE MODE` 加 IS 锁
  - intention exclusive lock (IX) 表示事务意图获取表中某些 row 的 X 锁
    - `SELECT ... FOR UPDATE` 加 IX 锁
  - 意向锁协议如下：
    - 事务在获取 row 的 S 锁前，必须先获取 table 的 IS 或级别更高的锁
    - 事务在获取 row 的 X 锁前，必须先获取 table 的 IX 锁

  - 表级别锁类型兼容性整理如下：

  |    |X|IX|S|IS|
  |:---:|:---:|:---:|:---:|:---:|
  |X|Conflict|Conflict|Conflict|Conflict|
  |IX|Conflict|Compatible|Conflict|Compatible|
  |S|Conflict|Conflict|Compatible|Compatible|
  |IS|Conflict|Compatible|Compatible|Compatible|

  A lock is granted to a requesting transaction if it is compatible with existing locks, but not if it conflicts with existing locks. A transaction waits until the conflicting existing lock is released. If a lock request conflicts with an existing lock and cannot be granted because it would cause deadlock, an error occurs.

意向锁不阻止全表操作请求（例如 `LOCK TABLES ... WRITE`）以外的加锁请求。使用意向锁就是为了说明某个事务正在或将要对表中的某些 row 加锁。

意向锁是 InnoDB 自动加的，不需用户干预。如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就将请求的锁授予该事务；反之如果两者不兼容，该事务就要等待锁释放。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及数据集加排他锁（X)；对于普通 SELECT 语句，InnoDB 不会加任何锁；

用 SELECT ... IN SHARE MODE 获得 IS，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行 UPDATE 或者 DELETE 操作。但是在多个事务均获得共享锁后对该记录进行更新操作，则可能造成死锁。对于锁定行记录后需要进行更新操作的应用，应该使用 SELECT... FOR UPDATE 方式获得 IX。

#### 行锁、间隙锁、next-key 锁、插入意向锁、自增锁、空间索引预测锁

- 行锁(Record Lock)
  - 是对索引记录加的锁
    - 若表无任何索引，则创建并使用隐藏的聚簇索引：[14.6.2.1, Clustered and Secondary Indexes](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)
  - 只有使用索引检索数据 InnoDB 才使用行级锁，否则 InnoDB 将使用表锁
  - 不同行记录如果是使用相同的索引行会出现锁冲突
  - 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。
  - 即使 WHERE 条件使用了索引 MySQL 仍有可能使用表锁
    - 是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，
    - 如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引
- 间隙锁(Gap Lock)
  - RR 级别，InnoDB
  - 使用**范围条件**查询且要求加共享锁或排他锁时 InnoDB 会给查询结果数据的索引项加锁
  - 给范围条件内（即使是并不存在的记录）加锁
    - > gaps between all existing values in the range are locked.
  - > A gap might span a single index value, multiple index values, or even be empty.
  - `SELECT FROM t_user WHERE key_col>0 FOR UPDATE;`
  - 对于加锁读(`SELECT with FOR UPDATE or LOCK IN SHARE MODE`), UPDATE, and DELETE 来说：
    - 加锁时取决于查询语句是否使用 unique index 和 unique search condition, or a range-type search condition.
    - 使用唯一索引的查询时只会加行锁，锁住记录对应的索引，不会加间隙锁。
      - 不包括查询条件只包括联合唯一索引的情况
    - 使用非唯一索引的查询时除了会加行锁，锁住记录对应的索引，还会使用 gap locks 或 next-key locks 以阻塞其他事务插入数据到当前查询范围覆盖的 gaps。
  - Gap lock 仅是为了防止其他事务插入数据到 gap 里。
  - Gap lock 可以共存
  - 目的
    - 防止其他事务插入造成幻读，满足隔离级别的要求
    - 满足数据恢复和复制的需要
  - 问题
    - 查询不当可能造成表锁
    - 若索引未覆盖全部查询条件可能会锁定部分范围外的行
    - 两个线程同时使用 SELECT FOR UPDATE 查询**不存在**的记录（RR 级别下）
      - 两个事务可以同时执行获取到锁
      - 但任何一个事务执行 INSERT 都会报死锁的错误
  - 使用 = 查询不存在的记录也会加锁；
- next-key 锁(行锁和间隙锁的组合)
  - RR 级别下会以此方式对数据加锁减少幻读问题
  - 索引记录的行锁 + 索引记录之前的 gap 的 gap lock
  - InnoDB 采用如下行锁机制：
    - 查找扫描索引时，在扫描到的索引记录上加 S 或 X 锁
    - 这样行锁实际上就是索引记录的锁
    - 索引记录上的 next-key 锁也会影响到索引记录前的 gap
      - 若某事务持有了索引记录的 X 或 S 锁，其他事务则不能立刻在该索引记录前的 gap 插入新索引记录。
      - 举个例子，index包括 10, 11, 13, and 20. 可能的 next-key 锁如下：
        - (negative infinity, 10]
        - (10, 11]
        - (11, 13]
        - (13, 20]
        - (20, positive infinity)
  - 防止 RR 下出现 phantom rows (see Section [14.7.4, “Phantom Rows”](https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html)).
- Insert Intention Locks
  - 插入数据之前在 row 前的加的一种 gap lock
  - 这个锁使得多个事务插入数据到同一 index gap 不同位置的时候无需相互等待
- AUTO-INC Locks
  - 事务插入自增列时的 table 锁
  - 一个事务必须等待另一个事务插入完后才能继续插入，以保证自增连续
  - `innodb_autoinc_lock_mode` 参数
- Predicate Locks for Spatial Indexes
  - 此处不表

### 锁粒度

尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。在给定的资源上锁定的数据量越少则系统的并发程度越高。基于锁的开销、数据安全性和性能方面的平衡，MySQL 在多种存储引擎上实现了多种的锁策略。

- 表锁
  - LOCK TABLES/UNLOCK TABLES
  - `show status like 'table%'`
  - `show engine innodb status;show processlist;show status like '%lock%'`
  - `SHOW STATUS LIKE 'InnoDB_row_lock%'` 查看行锁状态
- 全局锁
  - 获取方式
    - `FLUSH TABLES WITH READ LOCK`
    - 设置 `read_only=1`
  - 它与任何表锁都冲突
- 命名锁
  - 在重命名或删除一个表时创建，命名锁与普通的表锁相冲突。
  - `show opentables;`
- 字符锁
  - 用 `GET_LOCK()` 及其相关函数在服务器级别内锁住和释放任意一个字符串。

## MySQL 的事务

主要整理 InnoDB 引擎的事务实现。

### 事务日志

事务日志可以帮助提高事务的效率，简述如下：

使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。

事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。

事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。

如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。

### 事务实现

关于数据库事务隔离级别等概念，请访问 [数据库事务](/2018/05/01/database/#数据库事务)

- 自动提交

MySQL 默认采用自动提交模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置 `AUTOCOMMIT` 变量来启用或者禁用自动提交模式：

```sql
SHOW VARIABLES LIKE 'AUTOCOMMIT';
SET AUTOCOMMIT=0;// 1,ON 表示启用 0,OFF 表示禁用
```

另外有些命令会强制提交当前的活动事务，比如 DDL 语句中导致大量数据修改的 `ALTER TABLE` 语句，另外 `LOCK TABLES` 等也是。

- 隔离级别

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT @@tx_isolation;
SELECT @@global.tx_isolation;
```

- 显示锁定与隐式锁定

InnoDB 采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB 会根据隔离级别在需要的时候自动加锁。

另外，InnoDB 也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范：

```sql
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```

MySQL 也支持 LOCK TABLES 和 UNLOCK TABLES 语句，这是在服务器层实现的，和存储引擎无关。但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。

注意：LOCK TABLES 和事务之间相互影响的情况非常复杂，除了事务中禁用了 AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行 LOCK TABLES，不管使用的是什么存储引擎。

### MVCC 机制

官网文档参考：[14.3 InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html)、[14.7.2.1 Transaction Isolation Levels](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html)、**[14.7.1 InnoDB Locking](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)**、[14.7.2.3 Consistent Nonlocking Reads](https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html)

根据官方文档里关于 RR 级别的锁说明，整理如下：

- RR 是 InnoDB 的默认隔离级别
  - 即同一个事务内的 SELECT 均基于 first read 时的快照.

多版本并发机制极大地提升了并发性能。MVCC 通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

#### 两个隐藏列

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，分别保存了行的**创建**版本、行的**过期**版本（或**删除**版本）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在 REPEATABLE READ 隔离级别下，MVCC 具体是如何操作的：

- SELECT
  - 查询满足以下两个条件的记录：
  - 创建版本小于或等于当前事务版本。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
  - 行的删除版本为空，或者大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
- INSERT
  - 为插入的每一行保存当前系统版本号作为创建版本。
- DELETE
  - 为删除的每一行保存当前系统版本号作为删除版本。
- UPDATE
  - 插入一行新记录，保存当前系统版本号作为行创建版本号，同时保存当前系统版本号到原来的行作为行删除标识。？？？此处描述细节待确认？？？

#### 快照读、当前读

- 快照读
  - 执行 SELECT 时 InnoDB 默认执行快照读，会记录下此次查询结果
  - 后续 SELECT 时会返回这个数据
  - 这样其余事务提交就不会影响当前 SELECT 的结果，实现了可重复读
    - 注意如下场景：
    1. A 开启事务
    2. B 开启事务，写入数据 x，提交事务。
    3. A 查询数据，返回结果是包括 x 的（x 符合 WHERE 条件）。
    4. B 再开启事务写入数据 y，提交事务。
    5. A 查询数据结果不会变。
- **当前读**
  - 对于会对数据修改的操作(update、insert、delete)都会采用当前读模式
  - 执行操作时会读取最新的记录，即会读取其他事务已提交的数据。
  - 假设要 UPDATE 一条记录
    - 另一个事务中已经 DELETE 掉这条数据并且 COMMIT 了
    - 如果 UPDATE 就会失败

## 查询优化

表结构与索引、SQL语句优化、MySQL参数优化、硬件及系统配置，按照这个顺序，优化成本逐渐增加，优化效果逐渐明显。

预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；

如何对容量进行评估，如何适当分库分表来保证未来服务的可扩展性

### explain 详解

左侧深度优先的查询执行计划。

- `id` 编号
- `select_type` 查询类型
  - 简单查询 SIMPLE 不包括子查询和 union
  - 复杂查询
    - `PRIMARY` 外层标记
    - `SUBQUERY` 包含在 SELECT 列中的子查询中的 SELECT（不在 FROM 子句中）
    - `DERIVED` 包含在 FROM 子句的子查询中的 SELECT
    - `UNION` UNION 中的第二个和随后的SELECT被标记为UNION
- `table` 对应正在访问的表/别名
- `type`
  - ALL 全表扫描
  - index 按索引顺序全表扫描
  - range 指定范围内的索引扫描
  - ref 返回匹配某值的行
  - eq_ref 返回匹配某值的一行
  - const,system 可以将某部分查询优化为常量，不再需要关联
  - NULL 说明不用再访问索引和表
- `possible_keys` 初期判断可能使用的索引
- `key` 优化器采用的索引
- `key_len` 索引使用的字节数
- `ref` 和前方表连接的字段,const代表是常量值连接
- `rows` 预估需要查找的行数
- `filtered`
  - 针对表里符合某个条件（WHERE 子句或联接条件）的记录数的百分比所做的一个悲观估算
- `Extra`
  - Using index 使用覆盖索引从而避免回表
  - Using where 将在查询后过滤
  - Using temporary 对查询结果排序时将使用临时表
  - Using filesort 采用文件排序

## join 优化注意点
### 索引失败分析
## mvcc
## redo、undo
## 分库分表
## 弹性扩容
