---
layout: post
title: MySQL 数据库相关知识整理
categories: Database
description: MySQL 数据库相关知识整理
keywords: database, mysql, 原理, 数据库
---

MySQL 数据库在互联网业务中的地位无需多言，本文从各个方面整理 MySQL 数据库的知识点。

关于数据库基础理论知识，请查看：[数据库基础整理](/2018/05/01/database)。

## 底层原理

MySQL 底层是使用了哪些技术，使得其具备高性能的特性呢？

### 逻辑组成结构

![image](/images/posts/mysql_structure.png)

- 连接处理层
  - 客户端网络连接处理
  - 授权认证
  - 安全认证等
- 核心层
  - 查询解析
  - 分析优化
  - 缓存
  - 函数、存储过程、触发器、视图
- 存储引擎层
  - 执行事务处理操作
  - 数据存储和读取
  - 不解析 SQL，只是响应上层请求
  - 实现锁机制

### 存储引擎

MySQL 的存储引擎主要包括：

- MyISAM
  - 低版本默认引擎
  - 支持全文检索、压缩、空间函数
  - 不支持事务和行级锁
  - 对全表加锁
- InnoDB
  - 高版本默认引擎
  - 默认的事务性引擎
  - 性能优越、自动崩溃回复特性
  - 采用 MVCC 实现高并发、实现不同隔离级别
  - 基于聚簇索引建立表
  - 采用可预测性预读的技术从磁盘加载数据
- Archive/Memory/CSV 等

InnoDB 存储引擎的最小存储单元是页，一个页的大小是 16K(对应参数 `innodb_page_size`)。可以查看后缀为 ibd 的数据文件，其大小始终为 16K(10384) 字节的整数倍。

## 并发控制

当多个查询需要在同一时刻修改数据，就会产生并发控制的问题。解决这类问题的方法就是并发控制。

### 锁类型

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。

- 读锁

读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。

- 写锁

写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 锁粒度

尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。在给定的资源上锁定的数据量越少则系统的并发程度越高。基于锁的开销、数据安全性和性能方面的平衡，MySQL 在多种存储引擎上实现了多种的锁策略。

- 表锁
- 行级锁

## MySQL 的事务

主要整理 InnoDB 引擎的事务实现。

### 事务日志

事务日志可以帮助提高事务的效率，简述如下：

使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。

事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。

事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。

如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。

### 事务实现

- 自动提交

MySQL 默认采用自动提交模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置 `AUTOCOMMIT` 变量来启用或者禁用自动提交模式：

```sql
SHOW VARIABLES LIKE 'AUTOCOMMIT';
SET AUTOCOMMIT=0;// 1,ON 表示启用 0,OFF 表示禁用
```

另外有些命令会强制提交当前的活动事务，比如 DDL 语句中导致大量数据修改的 `ALTER TABLE` 语句，另外 `LOCK TABLES` 等也是。

- 隔离级别

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT @@tx_isolation;
select @@global.tx_isolation;
```

- 显示锁定与隐式锁定

InnoDB 采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB 会根据隔离级别在需要的时候自动加锁。

另外，InnoDB 也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范：

```sql
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```

MySQL 也支持 LOCK TABLES 和 UNLOCK TABLES 语句，这是在服务器层实现的，和存储引擎无关。但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。

注意：LOCK TABLES 和事务之间相互影响的情况非常复杂，除了事务中禁用了 AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行 LOCK TABLES，不管使用的是什么存储引擎。

### MVCC 机制

官网文档参考：[14.3 InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html)

多版本并发机制极大地提升了并发性能。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，分别保存了行的**创建**版本、行的**过期**版本（或**删除**版本）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在 REPEATABLE READ 隔离级别下，MVCC 具体是如何操作的。

- SELECT
  - 符合以下两个条件的记录才能作为查询结果返回：
  - 1. 查找创建版本小于或等于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
  - 2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
- INSERT
  - 为插入的每一行保存当前系统版本号作为创建版本。
- DELETE
  - 为删除的每一行保存当前系统版本号作为删除版本。
- UPDATE
  - 插入一行新记录，保存当前系统版本号作为行创建版本号，同时保存当前系统版本号到原来的行作为行删除标识。？？？此处描述细节待确认？？？

## 索引

- 索引速度快的原理

正常情况下在查询数据时，需要遍历磁盘扇区内所有数据；通过在索引中记录待查询字段、记录对应位置，可以快速筛选出结果集；假如需要回表查询非索引字段，只需要根据索引中记录的扇区位置查找对应行数据即可。

### B-Tree

B-tree（B树）的每个节点可以拥有2个以上的子节点，是一颗多路平衡查找树，它广泛应用于数据库索引和文件系统中。

### B+Tree

每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历

每个节点的指针上限为2d而不是2d+1

内节点不存储data，只存储key；叶子节点不存储指针。

每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。


## 索引

主键索引、唯一索引、普通索引、联合索引、全文索引

### 索引实现

- B+ 树实现：B+ 树比较适合用作 '>' 或 '<' 这样的范围查询，是 MySQL 中最常使用的一种索引实现。
- Hash：是使用散列表来对数据进行索引，Hash 方式不像 B-tree 那样需要多次查询才能定位到记录，因此 Hash 索引的效率高于 B-tree，但是不支持范围查找和排序等功能，实际使用的也比较少。
- FullText：就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。
- R-tree：是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。

## 调优

表结构与索引、SQL语句优化、MySQL参数优化、硬件及系统配置

按照这个顺序，优化成本逐渐增加，优化效果逐渐明显。

预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；

如何对容量进行评估，如何适当分库分表来保证未来服务的可扩展性

## 查询优化

明明建立了索引的语句，但是查询效率还是很慢，通过 Explain 分析发现表中有多个索引，MySQL 的优化器选用了错误的索引，导致查询效率偏低，然后通过在SQL语句中使用Use Index来指定索引解决。

## explain 详解
## join 优化注意点
### 索引失败分析
## mvcc
## redo、undo
## 分库分表
## 弹性扩容
