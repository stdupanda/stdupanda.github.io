---
layout: post
title: MySQL 数据库相关知识整理
categories: Database
description: MySQL 数据库相关知识整理
keywords: database, mysql, 原理, 数据库
---

MySQL 数据库在互联网业务中的地位无需多言，本文从各个方面整理 MySQL 数据库的知识点。

关于数据库基础理论知识，请查看：[数据库基础整理](/2018/05/01/database)。

## 底层原理

MySQL 底层是使用了哪些技术，使得其具备高性能的特性呢？

### 逻辑组成结构

![image](/images/posts/mysql_structure.png)

- 连接处理层
  - 客户端网络连接处理
  - 授权认证
  - 安全认证等
- 核心层
  - 查询解析
  - 分析优化
  - 缓存
  - 函数、存储过程、触发器、视图
- 存储引擎层
  - 执行事务处理操作
  - 数据存储和读取
  - 不解析 SQL，只是响应上层请求
  - 实现锁机制

### 存储引擎

MySQL 的存储引擎主要包括：

- MyISAM
  - 低版本默认引擎
  - 支持全文检索、压缩、空间函数
  - 不支持事务和行级锁
  - 对全表加锁
- InnoDB
  - 高版本默认引擎
  - 默认的事务性引擎
  - 性能优越、自动崩溃回复特性
  - 采用 MVCC 实现高并发、实现不同隔离级别
  - 基于聚簇索引建立表
  - 采用可预测性预读的技术从磁盘加载数据
- Archive/Memory/CSV 等

InnoDB 存储引擎的最小存储单元是页，一个页的大小是 16K(对应参数 `innodb_page_size`)。可以查看后缀为 ibd 的数据文件，其大小始终为 16K(10384) 字节的整数倍。

## 并发控制

当多个查询需要在同一时刻修改数据，就会产生并发控制的问题。解决这类问题的方法就是并发控制。

### 锁类型

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。

- 读锁

读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。

- 写锁

写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 锁粒度

尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。在给定的资源上锁定的数据量越少则系统的并发程度越高。基于锁的开销、数据安全性和性能方面的平衡，MySQL 在多种存储引擎上实现了多种的锁策略。

- 表锁
- 行级锁

### MySQL 的锁

- 表锁
  - LOCK TABLES/UNLOCK TABLES
  - `show status like 'table%'`
  - `show engine innodb status;show processlist;show status like '%lock%'`
- 全局锁
  - 获取方式
    - `FLUSH TABLES WITH READ LOCK`
    - 设置 `read_only=1`
  - 它与任何表锁都冲突
- 命名锁
  - 在重命名或删除一个表时创建，命名锁与普通的表锁相冲突。
  - `show opentables;`
- 字符锁
  - 用 `GET_LOCK()` 及其相关函数在服务器级别内锁住和释放任意一个字符串。

## MySQL 的事务

主要整理 InnoDB 引擎的事务实现。

### 事务日志

事务日志可以帮助提高事务的效率，简述如下：

使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。

事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。

事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。

如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。

### 事务实现

- 自动提交

MySQL 默认采用自动提交模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置 `AUTOCOMMIT` 变量来启用或者禁用自动提交模式：

```sql
SHOW VARIABLES LIKE 'AUTOCOMMIT';
SET AUTOCOMMIT=0;// 1,ON 表示启用 0,OFF 表示禁用
```

另外有些命令会强制提交当前的活动事务，比如 DDL 语句中导致大量数据修改的 `ALTER TABLE` 语句，另外 `LOCK TABLES` 等也是。

- 隔离级别

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT @@tx_isolation;
select @@global.tx_isolation;
```

- 显示锁定与隐式锁定

InnoDB 采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB 会根据隔离级别在需要的时候自动加锁。

另外，InnoDB 也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范：

```sql
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```

MySQL 也支持 LOCK TABLES 和 UNLOCK TABLES 语句，这是在服务器层实现的，和存储引擎无关。但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。

注意：LOCK TABLES 和事务之间相互影响的情况非常复杂，除了事务中禁用了 AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式地执行 LOCK TABLES，不管使用的是什么存储引擎。

### MVCC 机制

官网文档参考：[14.3 InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html)

多版本并发机制极大地提升了并发性能。MVCC 通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，分别保存了行的**创建**版本、行的**过期**版本（或**删除**版本）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在 REPEATABLE READ 隔离级别下，MVCC 具体是如何操作的：

- SELECT
  - 符合以下两个条件的记录才能作为查询结果返回：
  - 1. 查找创建版本小于或等于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
  - 2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
- INSERT
  - 为插入的每一行保存当前系统版本号作为创建版本。
- DELETE
  - 为删除的每一行保存当前系统版本号作为删除版本。
- UPDATE
  - 插入一行新记录，保存当前系统版本号作为行创建版本号，同时保存当前系统版本号到原来的行作为行删除标识。？？？此处描述细节待确认？？？

- 间隙锁防止幻读

## 索引和优化

- 索引速度快的原理

正常情况下在查询数据时，需要遍历磁盘扇区内所有数据；通过在索引中记录待查询字段、记录对应位置，可以快速筛选出结果集；假如需要回表查询非索引字段，只需要根据索引中记录的扇区位置查找对应行数据即可。

InnoDB表是基于聚簇索引建立的，我们会在后面的章节详细讨论聚簇索引。InnoDB的索引结构和MySQL的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index），以及能够加速插入操作的插入缓冲区（insert buffer）等。

- 索引类型
  - 主键索引、唯一索引、普通索引、联合索引、全文索引
  - B-Tree
  - Hash
  - R-Tree
  - fulltext
- 索引优点
  - 减少扫描数据量
  - 避免临时排序和临时表
  - 将随机 I/O 变为顺序 I/O
- 联合索引 index merge
- 优化策略
  - 反例
    - 参与函数计算
    - 隐式类型转换（会导致索引失效）
  - 正例
    - varchar 前缀索引指定长度
      - 确定区分度方式见下面 sql 片段
      - 可以使得索引更小、更有效
      - 缺点：无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。
    - 唯一特性字段必建 unique 索引
    - 禁止左模糊/全模糊查询
    - order by 字段的索引有序性
      - 正例：`where a =? and b =? order by c;` 索引： `a_b_c` 正常生效
      - 反例：索引中有范围查找，那么索引有序性无法利用，如：`WHERE a >10 ORDER BY b;` 索引
           `a_b` 无法排序
    - 利用覆盖索引避免回表
    - 利用延迟关联或子查询优化大量数据分页场景
    - 区分度高的索引在左边，区分度低的（如性别年龄省份等字段）在后面
- 优化目标指标
  - 最低 `range`，要求是 `ref`，`consts` 最好
  - 若 `type=index` 相当于全表扫描性能最差

```sql
-- varchar 列区分度判断
SELECT COUNT(*) AS cnt,LEFT(city,3) AS pref FROM t_city GROUP BY pref ORDER BY cnt DESC LIMIT 10; -- 查找合适的列
SELECT COUNT(DISTINCT LEFT(列名, 索引长度))/COUNT(*) FROM t_city;
ALTER TABLE t_city ADD KEY (city(6));-- 设置索引长度
```

延迟关联示例如下：

```sql
SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id; -- 阿里开发手册示例
SELECT a.* FROM 表 1 a, (select id from 表 1 where id > 100000 LIMIT 20 ) b where a.id=b.id;
-- (sex，rating) 索引
SELECT <cols> FROM profiles INNER JOIN (
 SELECT <primary key cols> FROM profiles
 WHERE x.sex='M' ORDER BY rating LIMIT 100000, 10
AS x USING(<primary key cols>);
```

- 优化的方向

  明明建立了索引的语句，但是查询效率还是很慢，通过 Explain 分析发现表中有多个索引，MySQL 的优化器选用了错误的索引，导致查询效率偏低，然后通过在SQL语句中使用Use Index来指定索引解决。

  - 建立索引
  - 按顺序建立索引
  - 尽量覆盖索引避免回表
  - “三星”索引原则
    - 索引将相关的记录放到一起则获得一星；
    - 如果索引中的数据顺序和查找中的排列顺序一致则获得二星；
    - 如果索引中的列包含了查询中需要的全部列则获得“三星”。
- 异常优化原因/不走索引
  - 执行计划的成本估算与实际执行成本异常

EXISTS 索引？

分组查询的SELECT中直接使用非分组列。建议始终使用含义明确的语法。事实上，我们建议将MySQL的SQL_MODE设置为包含 ONLY_FULL_GROUP_BY，这时MySQL会对这类查询直接返回一个错误，提醒你需要重写这个查询。

> `ONLY_FULL_GROUP_BY` Reject queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are neither named in the GROUP BY clause nor are functionally dependent on (uniquely determined by) GROUP BY columns.


### 聚簇索引

聚簇索引是一种数据存储方式，InnoDB 的在实现聚簇索引时，将**索引**和**数据行**保存在了同一个结构。

非聚簇索引就是指 B+Tree 的叶子节点上的 data 并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的 key 一定得是唯一的。主要用在 MyISAM 存储引擎中。

非聚簇索引比聚簇索引多了一次读取数据的 I/O 操作，所以查找性能上会差。

- 主键按顺序插入是最快的插入方式，否则建议 `OPTIMIZE TABLE`
- 更新聚簇索引列的代价较高，会强制被更新的行移动到新位置
- 可能会导致全表扫描变慢，比如行稀疏、页分裂导致存储不连续时

### B-Tree

B-Tree 的每个节点可以拥有 2 个以上的子节点，是一颗多路平衡查找树，它广泛应用于数据库索引和文件系统中。

### B+Tree

每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历

每个节点的指针上限为2d而不是2d+1

内节点不存储data，只存储key；叶子节点不存储指针。

每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。

## 索引

### 索引长度

varchar 类型字段的索引长度默认是最大长度 255 个字符，MySQL 默认每个 utf-8 字符占 3 字节。

### 索引实现

- B+ 树实现：B+ 树比较适合用作 '>' 或 '<' 这样的范围查询，是 MySQL 中最常使用的一种索引实现。
- Hash：是使用散列表来对数据进行索引，Hash 方式不像 B-tree 那样需要多次查询才能定位到记录，因此 Hash 索引的效率高于 B-tree，但是不支持范围查找和排序等功能，实际使用的也比较少。
- FullText：就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。
- R-tree：是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。

### 数据存储碎片化

- 行碎片
  - 数据被存储在多个地方
- 行间碎片
  - 逻辑上连续的行却不是顺序存储
- 剩余空间碎片
  - 数据页中有大量空余空间

```sql
OPTIMIZE TABLE <table>; -- MyISAM
ALTER TABLE <table> ENGINE=<engine>; -- InnoDB 换为同一个引擎
```

## 调优

表结构与索引、SQL语句优化、MySQL参数优化、硬件及系统配置

按照这个顺序，优化成本逐渐增加，优化效果逐渐明显。

预计1年后用户数据10亿条，写QPS约5000，读QPS30000，可以设计按UID纬度进行散列，分为4个库每个库32张表，单表数据量控制在KW级别；

如何对容量进行评估，如何适当分库分表来保证未来服务的可扩展性


## explain 详解

左侧深度优先的查询执行计划。

- `id` 编号
- `select_type` 查询类型
  - 简单查询 SIMPLE 不包括子查询和 union
  - 复杂查询
    - `PRIMARY` 外层标记
    - `SUBQUERY` 包含在 SELECT 列中的子查询中的 SELECT（不在 FROM 子句中）
    - `DERIVED` 包含在 FROM 子句的子查询中的 SELECT
    - `UNION` UNION 中的第二个和随后的SELECT被标记为UNION
- `table` 对应正在访问的表/别名
- `type`
  - ALL 全表扫描
  - index 按索引顺序全表扫描
  - range 指定范围内的索引扫描
  - ref 返回匹配某值的行
  - eq_ref 返回匹配某值的一行
  - const,system 可以将某部分查询优化为常量，不再需要关联
  - NULL 说明不用再访问索引和表
- `possible_keys` 初期判断可能使用的索引
- `key` 优化器采用的索引
- `key_len` 索引使用的字节数
- `ref` 和前方表连接的字段,const代表是常量值连接
- `rows` 预估需要查找的行数
- `filtered`
  - 针对表里符合某个条件（WHERE 子句或联接条件）的记录数的百分比所做的一个悲观估算
- `Extra`
  - Using index 使用覆盖索引从而避免回表
  - Using where 将在查询后过滤
  - Using temporary 对查询结果排序时将使用临时表
  - Using filesort 采用文件排序

## join 优化注意点
### 索引失败分析
## mvcc
## redo、undo
## 分库分表
## 弹性扩容
